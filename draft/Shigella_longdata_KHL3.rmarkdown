---
title: "Longitudinal analysis of Shigella"
format: 
  pdf:
    number-sections: true
    number-depth: 2
    number-offset: [0, 0]
editor: visual
output:
  pdf_document:
    orientation: landscape
---

```{r setup, include=FALSE,echo=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, message=FALSE}
library(gridExtra)
library(haven)
library(knitr)
library(plotly)
library(kableExtra)
library(tidyr)
library(arsenal)
library(dplyr)
library(forcats)
library(huxtable)
library(magrittr)
library(parameters)
library(kableExtra)
library(ggplot2)
library(ggeasy)
library(scales)
library(plotly)
library(patchwork)
library(tidyverse)
library(gtsummary)
library(readxl)
library(skimr)

library(serocalculator)
library(runjags)
library(coda)
library(ggmcmc)
library(here)

```



## Data description

-   Step 1: Load the Dataset



```{r}
df <- read_excel("3.8.2024 Compiled Shigella datav2.xlsx", 
                      sheet = "Compiled")
```



-   Step 2: Get a Quick Overview of the Data Structure



```{r, echo=FALSE, message=FALSE}
skim(df) # Provides a comprehensive summary including missing values, distribution, and data types

```



-   Step 3: Identify and Summarize Missing Values (for the entire dataset and the SOSAR study)



```{r, echo=FALSE, message=FALSE}
missing_summary <- df %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "missing_count") %>%
  arrange(desc(missing_count))

print(missing_summary)
```

```{r, echo=FALSE, message=FALSE}

df_sosar<-df%>%filter(study_name=="SOSAR")


missing_summary2 <- df_sosar %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(cols = everything(), names_to = "variable", values_to = "missing_count") %>%
  arrange(desc(missing_count))

print(missing_summary2)
```



## Exploratory Data Analysis

-   Step 4: Filter Data for the SOSAR Study and Split Data by Isotype



```{r, echo=FALSE, message=FALSE}
# select longitudinal dataset from complied dataset

# split the data by isotype

df_sosar_IgA<-df_sosar%>%filter(isotype_name=="IgA")

df_sosar_IgG<-df_sosar%>%filter(isotype_name=="IgG")

```


Verifying the unique sample identification numbers (SIDs) is crucial. There are 48 SIDs in this SOSAR study.


\newpage

-   Step 5: Plot Quantitative Response Change Over Time



```{r, echo=FALSE, message=FALSE}
# plotting how quantitative response change over time within individuals

# Check the number of observations per sid
df_summary_IgA <- df_sosar_IgA %>%
  group_by(sid) %>%
  summarize(count = n()) %>%
  filter(count > 1)


```

```{r, echo=FALSE, message=FALSE}
# Filter the original dataframe to include only individuals with more than one observation
df_filtered_IgA <- df_sosar_IgA %>%
  filter(sid %in% df_summary_IgA$sid)

# Plotting ipab_MFI over time for each individual
ggplot(df_filtered_IgA, aes(x = timepoint, y = ipab_MFI, group = sid, color = sid)) +
  geom_line() +
  geom_point() +
  labs(title = "Change in ipab_MFI Over Time",
       x = "Timepoint",
       y = "ipab_MFI",
       color = "Individual ID") +
  theme_minimal()+
  theme(legend.position = "none")
```



## Longitudinal Antibody Decay Modeling

-   Step 6: Prepare Data for JAGS Model



```{r, echo=FALSE, message=FALSE}
file.mod <- here::here("inst", "extdata", "model.jags.r")
```

```{r, echo=FALSE, message=FALSE}
# manipulating shigella data for applying dcm code
dL<-df_sosar%>%select(isotype_name,sid,cohort,age,treatment,timepoint,`Actual day`)%>%
  mutate(index_id=sid,antigen_iso=isotype_name,visit=timepoint,timeindays=`Actual day`)

dL<-dL%>%group_by(index_id, antigen_iso) %>%# Group data by individual
   arrange(visit) %>%  # Sort data by visit within each group
   mutate(visit_num = rank(visit, ties.method = "first")) %>%
   ungroup()
```



-   Step 7: Subset Data for Model Testing



```{r}
#subset data for checking
dL_sub <- dL %>%
 filter(index_id %in% sample(unique(index_id), 20))
```



-   Step 8: Prepare Data and Priors for JAGS



```{r, echo=FALSE, message=FALSE,include=FALSE}
# Construct the path to "prep_data.r" using here
prep_data_path <- here::here("R", "prep_data.r")
prep_priors_path <- here::here("R", "prep_priors.R")

# Source the file to load the prep_data function
source(prep_data_path)
source(prep_priors_path)

#prepare data for modeline
longdata <- prep_data(dL_sub)
priors <- prep_priors(max_antigens = longdata$n_antigen_isos)
```



-   Step 9: Run the JAGS Model



```{r, echo=FALSE, message=FALSE}
#inputs for jags model

nchains <- 4;                # nr of MC chains to run simultaneously
nadapt  <- 100;             # nr of iterations for adaptation
nburnin <- 100;            # nr of iterations to use for burn-in
nmc     <- 100;             # nr of samples in posterior chains
niter   <- 100;            # nr of iterations for posterior sample
nthin   <- round(niter/nmc); # thinning needed to produce nmc from niter

tomonitor <- c("y0", "y1", "t1", "alpha", "shape");


#This handles the seed to reproduce the results 
initsfunction <- function(chain){
 stopifnot(chain %in% (1:4)); # max 4 chains allowed...
 .RNG.seed <- (1:4)[chain];
 .RNG.name <- c("base::Wichmann-Hill","base::Marsaglia-Multicarry",
                "base::Super-Duper","base::Mersenne-Twister")[chain];
 return(list(".RNG.seed"=.RNG.seed,".RNG.name"=.RNG.name));
}


```

```{r}
dump_and_quit <- function() {
  dump.frames(to.file = TRUE)
  q(status = 1)
}
options(error = dump_and_quit)

```

```{r, echo=FALSE, message=FALSE}

print("Starting run.jags execution")

# Check the data being passed to JAGS
print(str(longdata))
print(str(priors))

jags.post <- try(run.jags(model = file.mod, 
                          data = c(longdata, priors),
                          inits = initsfunction,
                          method = "parallel",
                          adapt = nadapt,
                          burnin = nburnin,
                          thin = nthin,
                          sample = nmc,
                          n.chains = nchains,
                          monitor = tomonitor,
                          summarise = FALSE))

if (inherits(jags.post, "try-error")) {
  print("Error in run.jags:")
  print(jags.post)
} else {
  print("run.jags completed successfully")
}

```




## Model Fit Evaluation

-   Step 10: Covert JAGS Output to MCMC List and Evaluate Convergence



```{r}
mcmc_list <- as.mcmc.list(jags.post)

mcmc_df <- ggs(mcmc_list)

# Plot trace plots for diagnostics
traceplot(mcmc_list)

# Calculate R-hat values for convergence
print(gelman.diag(mcmc_list))

# Plot density plots for posterior distributions
densplot(mcmc_list)

```



-   Step 11: Posterior Predictive Checks



```{r, echo=FALSE, message=FALSE}
# Compare observed vs. predicted values
ppc_dens_overlay(y=longdata$y, yrep=as.matrix(mcmc_list[[1]]))

# Additional checks using bayesplot
mcmc_areas(mcmc_list,pars=tomonitor)
```




## Antibody Decay and Visualization

-   Step 12: Prepare Data for Serocalculator Package



```{r, echo=FALSE, message=FALSE}
wide_predpar_df <- mcmc_df %>%
 mutate(
   parameter = sub("^(\\w+)\\[.*", "\\1", Parameter),
   index_id = as.numeric(sub("^\\w+\\[(\\d+),.*", "\\1", Parameter)),
   antigen_iso = as.numeric(sub("^\\w+\\[\\d+,(\\d+).*", "\\1", Parameter))
 ) %>%
 mutate(
   index_id = factor(index_id, labels = c(unique(dL_sub$index_id), "newperson")),
   antigen_iso = factor(antigen_iso, labels = unique(dL_sub$antigen_iso))) %>%
   filter(index_id == "newperson") %>%
   select(-Parameter) %>%
   pivot_wider(names_from = "parameter", values_from="value") %>%
   rowwise() %>%
   droplevels() %>%
   ungroup() %>%
   rename(r = shape)

```

```{r, echo=FALSE, message=FALSE}
# Assuming wide_predpar_df is your data frame
curve_params <- wide_predpar_df

# Set class and attributes for serocalculator
class(curve_params) <- c("curve_params", class(curve_params))
antigen_isos <- unique(curve_params$antigen_iso)
attr(curve_params, "antigen_isos") <- antigen_isos

```



\newpage

-   Step 13: Plot Longitudinal Antibody Decay



```{r, echo=FALSE, message=FALSE}
plot.long <- autoplot(curve_params)
print(plot.long)

```



-   Step 14: Define the Antibody Calculation Function



```{r}
ab <- function(t, y0, y1, t1, alpha, shape) {
  beta <- log(y1/y0) / t1
  if (t <= t1) {
    yt <- y0 * exp(beta * t)
  } else {
    yt <- (y1^(1 - shape) - (1 - shape) * alpha * (t - t1))^(1 / (1 - shape))
  }
  return(yt)
}

```



-   Step 15: Generate Time Points for Antibody Levels



```{r, echo=FALSE, message=FALSE}
# Generate time points
tx2 <- 10^seq(-1, 3, 0.025)

# Prepare data frame with time points
dT <- data.frame(t = tx2) %>%
  mutate(ID = 1:n()) %>%
  pivot_wider(names_from = ID, values_from = t, names_prefix = "time") %>%
  slice(rep(1:n(), each = nrow(wide_predpar_df)))

```



-   Step 16: Calculate Antibody Levels Over Time



```{r, echo=FALSE, message=FALSE}
# Combine data and calculate antibody levels
serocourse.full <- cbind(wide_predpar_df, dT) %>%
  pivot_longer(cols = starts_with("time"), values_to = "t") %>%
  select(-name) %>%
  rowwise() %>%
  mutate(res = ab(t, y0, y1, t1, alpha, r)) %>%  ## this code doesn't work properly, check ab function
  ungroup()

```




\newpage

-   Step 17: Summarize and Plot Antibody Decay Data



```{r, echo=FALSE, message=FALSE}
# Summarize the serocourse data
serocourse.med <- serocourse.full %>%
  group_by(antigen_iso, t) %>%
  summarise(res.med = quantile(res, 0.5),
            res.low = quantile(res, 0.025),
            res.high = quantile(res, 0.975)) %>%
  pivot_longer(names_to = "quantile", cols = c("res.med", "res.low", "res.high"), names_prefix = "res.", values_to = "res")

```

```{r, echo=FALSE, message=FALSE}
# Plot the summarized data
serocourse_plot <- ggplot(serocourse.med, aes(x = t, y = res, color = quantile)) +
  geom_line() +
  facet_wrap(~ antigen_iso) +
  scale_x_log10() +
  labs(title = "Longitudinal Antibody Decay with Uncertainty Intervals",
       x = "Time (log scale)",
       y = "Antibody Level")

print(serocourse_plot)
```



If the IgA antibody has a higher high quantile compared to the IgG antibody in the "Longitudinal Antibody Decay with Uncertainty Intervals" plot, it implies the following:

- Higher Potential Peak Response

- Greater Variation in Responses

- Implications for Protection

- Potential for Long-Term Immunity
